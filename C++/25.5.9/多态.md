## 基本概念

多态是C++面向对象三大特性之一

多态分为两类：
- 静态多态：函数重载和运算符重载，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：
- 静态多态的函数地址早绑定，编译阶段确定函数地址
- 动态多态的函数地址晚绑定，运行阶段确定函数地址

示例：
```
#include <iostream>
using namespace std; 

class Animal {
public:
    void speak() {
        cout << "动物在说话" << endl;
    }
};  

class Cat : public Animal {
public:
    void speak() {
        cout << "小猫在说话" << endl;
    }
};  

void doSpeak(Animal &animal) {
    animal.speak();
}  

void test01() {
    Cat cat;
    doSpeak(cat);
}
  
int main() {
    test01();
    return 0;
}
```

运行结果如下：
![[tu1.png]]
这是因为函数地址早绑定了，在编译阶段就已经确定了doSpeak中点用的函数地址。因此，无论传递的参数如何，结果都是一样的。

若想执行Cat（或其他子类的同名函数），则需要函数晚绑定。只需在Animal（父类）的speak函数声明前加上`virtual`关键字就可以了。此时，这个speak函数被称为虚函数。

动态多态的满足条件：
1. 有继承关系
2. 子类重写父类的虚函数
    （重写：函数返回值类型、函数名、参数列表完全一致）

动态多态的使用：父类指针或引用指向子类对象

## 动态多态的原理

### 虚函数表（vtable）
- 当类中包含虚函数时，编译器会为该类生成一个虚函数表（vtable）
- vtable是一个函数指针数组，存储了该类所有虚函数的地址
- 每个包含虚函数的类对象都会隐式包含一个指向其vtable的指针（vptr）

### 虚指针（vptr，也称为虚函数表指针）
- 每个对象在构造时，其vptr会被初始化为指向对应类的vtable
- 通过这个指针，程序可以在运行时确定应该调用哪个虚函数实现

### 动态绑定过程
当通过基类指针或引用调用虚函数时：
1. 通过对象的vptr找到对应的vtable
2. 在vtable中查找要调用的虚函数的位置
3. 调用该位置的函数

###  继承体系中的vtable
- 派生类继承基类的vtable
- 如果派生类重写了虚函数，则替换vtable中对应的函数指针
- 如果派生类新增了虚函数，则添加到vtable的末尾

### 多态调用的开销
- 虚函数调用比普通函数调用多一次间接寻址（通过vptr访问vtable）
- 无法内联虚函数调用（因为运行时才能确定具体调用哪个函数）

### 注意事项
1. 构造函数不能是虚函数（因为构造时vptr尚未初始化）
2. 析构函数通常应该是虚函数（确保通过基类指针删除派生类对象时能正确调用派生类析构函数）
3. 虚函数机制只在使用指针或引用调用时才生效，通过对象直接调用时不使用多态

不含任何数据类型的类（只有成员函数）占1个字节大小，含虚函数、不含任何数据类型的类占4个字节大小（为虚函数指针）。

## 纯虚函数和抽象类

纯虚函数的语法：`virtual 返回值类型 函数名 (参数列表) = 0;`
当类有了纯虚函数，这个类就被称为抽象类。

抽象类的特点：
- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

示例：
```
class Base {
public:
    virtual void func() = 0;
};  

class Son : public Base {
public:
    void func() override {
        cout << "func 函数调用" << endl;
    }
};

void test01() {
    // 错误：不允许使用抽象类类型 "Base" 的对象: 函数 "Base::func" 是纯虚拟函数
    // Base base;  

    // 当Son类不重写纯虚函数func时，会报和上面一样的错
    // Son son;

    // 这段代码是正确的，此时base会动态地转换为Son类型
    Base *base = new Son;
    base->func();
}

int main() {
    test01();
    return 0;
}
```

## 虚析构和纯虚析构

多态使用时，若子类有属性开辟在堆区，那父类指针在释放时无法调用到子类的析构代码。
为此需要将父类的析构函数改为虚析构或纯虚析构。


相同点：
- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现
不同：
若是纯虚析构，该类属于抽象类，无法实例化对象