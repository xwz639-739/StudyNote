## 基本概念

HTTP（HyperText Transfer Protocol，超文本传输协议）适用于客户端和服务器之间数据传输的应用层协议，主要用在web览器和服务器之间的通信。HTTP最初是为传输HTML文档设计的，但现在支持多种类型的数据，如图片、视频、文本等。

无状态性：每个HTTP请求都是独立的，不记录之前的任何请求，请求一次，就返回一次。这简化了协议的实现，但可能会需要使用其他方式（如Cookies或Session）保存状态。

一次HTTP请求过程：
1. **建立连接**：当用户在浏览器中输入网址或点击链接时，浏览器首先会尝试与该网址所对应的Web服务器建立TCP连接。这一步骤涉及到DNS查找来解析域名成为IP地址，然后通过三次握手的过程建立起一个可靠的TCP连接。
2. **发送请求**：一旦连接建立成功，浏览器就会向服务器发送HTTP请求报文。这个请求报文包括请求行（如GET /index.html HTTP/1.1），表示请求的类型、路径和协议版本；接着是若干请求头，包含了关于浏览器的信息（如它能接受的内容类型）、Cookie等；最后可能还有一个空行后跟上请求体（主要用于POST请求）。
3. **服务器处理请求**：服务器接收到请求后，会根据请求的内容进行相应的处理。比如，如果是一个静态文件请求（像HTML页面或图片），服务器会直接读取文件内容。如果是动态请求，比如需要执行服务器端脚本来生成页面，则服务器会先执行这些脚本，再把结果作为响应返回。
4. **返回响应**：处理完请求之后，服务器构建一个HTTP响应报文并将其发送回客户端。响应报文包括状态行（如HTTP/1.1 200 OK），指示了响应的状态码和说明；响应头提供了关于响应的信息，如内容类型、长度等；以及响应体，即实际要返回给客户端的数据。
5. **关闭连接**：除非使用了持久连接（Keep-Alive），否则服务器会在发送完响应后关闭TCP连接。使用持久连接可以允许在同一对客户端和服务器之间传输多个HTTP请求和响应，无需为每个请求都重新建立连接。
6. **渲染页面**：客户端接收到响应后，浏览器开始解析响应内容。如果是HTML文档，浏览器会渲染页面，并可能会发出额外的请求来获取页面中的外部资源，如CSS文件、JavaScript文件和图片等，以完成整个页面的展示。
底层原理：
- **DNS解析**：当用户在浏览器中输入一个网址（URL），首先需要将这个人类可读的域名转换为机器可识别的IP地址。这一步通过DNS（Domain Name System）来完成。用户的计算机发送一个DNS查询到配置的DNS服务器，该服务器返回与域名相对应的IP地址。
- **建立TCP连接 - 三次握手**：
    - **SYN**：客户端向服务器发送一个SYN（同步序列编号，Synchronize Sequence Numbers）包作为第一次握手，表示希望与服务器建立连接。
    - **SYN-ACK**：服务器接收到SYN包后，会发送一个SYN-ACK（确认字符，Acknowledgement）包作为响应，表示同意建立连接，并且也携带了服务器的序列号。
    - **ACK**：最后，客户端发送一个ACK包给服务器，确认收到了服务器的SYN-ACK包，至此三次握手完成，双方进入连接状态，可以开始数据传输。
- **发送HTTP请求**：一旦TCP连接建立，浏览器就会构建HTTP请求报文并通过已建立的TCP连接发送给服务器。请求报文包含请求行、请求头和可能的请求体。
- **服务器处理及响应**：服务器接收到请求后，根据请求的内容进行处理，并准备相应的HTTP响应报文。响应报文同样包含状态行、响应头和响应体。服务器通过相同的TCP连接将响应发送回客户端。
- **四次挥手断开连接**：当数据交换完成后，为了关闭TCP连接，通常需要经历四次挥手的过程。
    - 首先，一方（通常是客户端）发送一个FIN（结束标志，Finish）包，表示想要断开连接。
    - 对方（服务器）接收到FIN后，回复一个ACK包，确认收到了结束请求，但此时可能还有未发送完的数据或未接收完的数据，所以不会立即关闭连接。
    - 当服务器准备好关闭连接时，也会发送一个FIN包给客户端。
    - 最后，客户端发送ACK包确认，随后等待一段时间以确保对方收到了ACK包，然后关闭连接。
- **页面渲染**：客户端接收到完整的响应后，浏览器开始解析HTML文档并逐步加载页面中的资源（如CSS、JavaScript、图片等），最终将网页呈现在用户面前。

HTTP的协议头：
	HTTP协议分为请求头和响应头
- 请求头：
	HTTP请求头包含三部分：请求行（构建请求阶段）、请求头、请求体
```
GET /index.html HTTP/1.1  ---> 请求行

Host: www.example.com     ---> 请求头
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: http://www.example.com/home
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Cookie: key1=value1; key2=value2

...                         ---> 请求体
```
	需要比较关注的：
	- Host：指定服务器的域名和端口号
	- User-Agent：描述客户端应用程序的名称和版本
	- Accept：指示客户端可以处理的媒体类型
	- Content-Type：指示请求主体的数据类型，常见于POST或PUT请求
	- Authorization：包含认证凭证，用于保护的资源访问
总结：

| 方法      | 描述                                           |
| ------- | -------------------------------------------- |
| GET     | 请求从服务器获取指定的资源。请求的参数包含在URL中，对数据量有限制，并且不应有副作用。 |
| POST    | 向指定资源提交数据进行处理请求（如提交表单、上传文件等）。数据包含在请求体中。      |
| PUT     | 向指定位置上传一个资源，如果目标资源已存在，则更新该资源。                |
| DELETE  | 请求服务器删除指定的资源。                                |
| HEAD    | 类似于GET请求，但服务器只返回响应头信息，而不返回响应体。               |
| OPTIONS | 用于查询针对服务器支持的请求方法，或者其他有关服务器的信息。               |
| CONNECT | 用于将连接转换到隧道模式，通常用于HTTPS加密通信。                  |
| TRACE   | 回显服务器收到的请求，主要用于诊断。                           |
| PATCH   | 用于对资源进行部分修改，不同于PUT方法会完全替换资源。                 |

- 响应头：
	服务器接收到客户端的请求，将作出处理并返回相应的数据，包含响应行、响应头、响应体
```
HTTP/1.1 200 OK    ----> 响应行

Date: Monday, 19 May 2025 10:30:45 GMT    ----> 响应头
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html; charset=UTF-8
Content-Length: 1024
Connection: keep-alive
Set-Cookie: sessionid=abc123xyz; Path=/
Cache-Control: max-age=3600
Expires: Mon, 19 May 2025 11:30:45 GMT
Last-Modified: Sun, 18 May 2025 08:23:10 GMT

...   ----> 响应体
```
	需要注意的有：
	- Content-Type：响应内容的媒体描述
	- Content-Length：指示响应主题的长度
	- Cache-Control：指定缓存策略
	- Set-Cookie：在客户端存储一个Cookie，以后可以用于会话管理
	- Server：提供服务器软件的信息

POST和GET的区别：
 **数据传输位置**
- **GET**：通过URL参数来传递数据，这些数据会附加在URL的末尾（例如：`http://example.com/page?key1=value1&key2=value2`）。由于数据直接暴露在URL中，因此可以通过浏览器地址栏看到。
- **POST**：通过HTTP请求体来传递数据，数据不会显示在URL中。这使得POST请求可以发送更多的数据，并且数据类型更加灵活，不限于文本数据。

 **安全性**
- **GET**：因为数据直接附在URL后面，所以相对不安全，特别是当需要发送敏感信息时（如密码）。而且，由于大多数情况下URL会被记录在浏览器历史记录、服务器日志等地方，这也增加了泄露的风险。
- **POST**：虽然POST请求的数据也不会被加密（除非使用HTTPS），但由于数据不在URL中公开，相对来说更安全一些。不过，仍需注意保护数据安全，尤其是在处理敏感信息时。

 **缓存与书签**
- **GET**：适合用于获取数据的操作，且支持缓存和书签功能。用户可以直接保存或分享URL以访问特定资源。
-  **POST**：主要用于提交数据到服务器进行处理，不建议用于获取数据。POST请求通常不会被缓存或添加到书签中，因为它涉及到改变服务器上的数据状态。

**幂等性和安全性**
- **GET**：被认为是幂等的，意味着无论执行多少次相同的GET请求，结果都是相同的。它也被认为是“安全”的，即它不应该引起服务器端的状态变化。
- **POST**：不是幂等的，重复提交可能会导致服务器上的数据多次变更（例如多次创建同一资源）。因此，POST请求不应被视为安全或幂等的。

 **数据大小限制**
- **GET**：由于数据通过URL传递，受到URL长度的限制（不同浏览器和服务器可能有不同的最大长度限制），一般不适合传输大量数据。
- **POST**：理论上没有严格的大小限制（取决于服务器配置），可以用来传输较大的数据量。

状态码：
**1xx（信息性状态码）**
- **100 Continue**：客户端应继续发送请求（用于大文件上传前确认）。
- **101 Switching Protocols**：服务器同意切换协议（如升级到WebSocket）。

**2xx（成功状态码）**
- **200 OK**：请求成功（最常用）。
- **201 Created**：资源创建成功（如POST提交后返回）。
- **204 No Content**：请求成功，但无返回内容（如DELETE请求）。
- **206 Partial Content**：分块下载或断点续传（响应`Range`头）。

**3xx（重定向状态码）**
- **301 Moved Permanently**：资源永久重定向（SEO会传递权重）。
- **302 Found**：资源临时重定向（浏览器默认GET方法，可能丢失POST数据）。
- **304 Not Modified**：资源未修改（命中浏览器缓存，与`If-Modified-Since`相关）。
- **307 Temporary Redirect**：临时重定向（强制保留原请求方法）。
- **308 Permanent Redirect**：永久重定向（强制保留原请求方法）。

**4xx（客户端错误状态码）**
- **400 Bad Request**：请求语法错误（如参数格式错误）。
- **401 Unauthorized**：未认证（需身份验证，如登录失效）。
- **403 Forbidden**：无权限访问（认证成功但权限不足）。
- **404 Not Found**：资源不存在（路径错误或资源已删除）。
- **405 Method Not Allowed**：请求方法不被允许（如GET接口用POST调用）。
- **408 Request Timeout**：请求超时（服务器等待超时）。
- **429 Too Many Requests**：请求频率过高（限流触发）。

**5xx（服务器错误状态码）**
- **500 Internal Server Error**：服务器内部错误（如代码异常）。
- **502 Bad Gateway**：网关/代理错误（如Nginx后端服务崩溃）。
- **503 Service Unavailable**：服务不可用（如服务器过载或维护）。
- **504 Gateway Timeout**：网关超时（如后端服务响应超时）。

HTTP的优缺点：
 **✅ 优点**
1. **简单易用**
    - 基于文本（早期版本）或二进制（HTTP/2+）的协议，报文结构清晰（请求行/头/体），易于开发和调试。
2. **灵活可扩展**
    - 支持自定义请求方法（如 `GET`/`POST`）和头部字段（Headers），可扩展性强（如 `X-` 前缀自定义头）。
    - 兼容多种数据格式（JSON/XML/二进制流等）。
3. **无状态（Stateless）**
    - 默认不记录客户端状态，简化服务器设计（可通过Cookie/Session人工实现状态管理）。
4. **跨平台和跨语言**
    - 基于TCP/IP，支持任意操作系统和编程语言（浏览器、移动端、IoT设备均可使用）。
5. **支持缓存**
    - 通过 `Cache-Control`、`ETag` 等头部字段优化性能，减少重复请求。
6. **分层设计**
    - 与底层协议（TCP/IP）解耦，方便升级（如HTTP/1.1 → HTTP/2 → HTTP/3）。

**❌ 缺点**
1. **明文传输（HTTP默认）**
    - 请求和响应内容未加密，易被窃听或篡改（需HTTPS补救）。
2. **无状态的双刃剑**
    - 每次请求独立，需额外手段（如Cookie/JWT）管理会话状态，增加开发复杂度。
3. **性能瓶颈（HTTP/1.1）**
    - 队头阻塞（Head-of-Line Blocking）：同一TCP连接下，前一个请求未完成会阻塞后续请求。
    - 高延迟：多次TCP握手（HTTP/1.1默认短连接，早期无Keep-Alive）。
4. **安全性依赖开发者**
    - 需手动防范漏洞（如CSRF、XSS、SQL注入），协议本身无强制安全机制。
5. **服务器推送限制**
    - 传统HTTP只能“请求-响应”，服务器无法主动推送数据（需WebSocket或HTTP/2 Server Push）。
6. **头部冗余（HTTP/1.x）**
    - 每次请求携带重复头部（如 `User-Agent`、`Cookie`），浪费带宽（HTTP/2通过压缩优化）。

## HTTP的版本演进

1. **HTTP/0.9（1991年）**
- **最初版本**，极其简单。
- 仅支持`GET`方法。
- 无请求头/响应头，无法传输其他类型的数据（如纯文本）。 
- 响应后立即关闭连接。
---
2. **HTTP/1.0（1996年，RFC 1945）**
- **正式标准化**，引入关键特性：
    - 支持多种方法（`GET`、`POST`、`HEAD`）。
    - 引入**请求头/响应头**（如`Content-Type`、`Status Code`），支持传输HTML以外的文件（如图片）。
    - 新增状态码（如`200 OK`、`404 Not Found`）。
    - 默认短连接（每个请求需重新建立TCP连接），性能较差。
---
3. **HTTP/1.1（1997年，RFC 2068；1999年更新为RFC 2616）**
- **最广泛使用的版本**，主要改进：
    - **持久连接（Keep-Alive）**：默认复用TCP连接，减少延迟。
    - **管道化（Pipelining）**：允许发送多个请求（但响应必须按顺序返回，易阻塞）。
    - 新增方法（`PUT`、`DELETE`、`OPTIONS`等）。
    - 引入`Host`头，支持虚拟主机（一个服务器托管多个域名）。
    - 缓存控制（如`Cache-Control`、`ETag`）。
- **缺点**：队头阻塞（Head-of-Line Blocking）、冗余头部（未压缩）。
---
4. **HTTP/2（2015年，RFC 7540）**
- **基于Google的SPDY协议**，核心改进：
    - **二进制协议（分帧）**：替代文本格式，解析更高效。
    - **多路复用（Multiplexing）**：同一连接上并行传输多个请求/响应，解决队头阻塞。
    - **头部压缩（HPACK）**：减少冗余。
    - **服务器推送（Server Push）**：主动推送资源（如CSS/JS）到客户端缓存。
    - 流优先级控制。
- **不足**：仍依赖TCP，可能因丢包影响性能。
---
5. **HTTP/3（2022年，RFC 9114）**
- **基于QUIC协议**（运行在UDP上），彻底解决TCP瓶颈：
    - **无队头阻塞**：即使丢包也只影响单个流。
    - **快速握手**：0-RTT或1-RTT建立连接，降低延迟。
    - **连接迁移**：切换网络（如WiFi→4G）时无需重新握手。
    - 继承HTTP/2的多路复用和头部压缩。
    - 内置TLS加密
- **现状**：逐步被主流浏览器和服务器（如Cloudflare、Nginx）支持。

适用场景：
**1. HTTP/1.0**
- **特点**：短连接、无Host头、仅支持GET/POST/HEAD方法。
- **使用场景**：
    - 早期静态网页（仅HTML）。
    - 已基本被淘汰，仅在某些遗留系统或嵌入式设备中可能仍在使用。
---
**2. HTTP/1.1**
- **特点**：持久连接（Keep-Alive）、Host头支持、管道化（Pipelining）、更丰富的缓存机制（如ETag、Cache-Control）。
- **使用场景**：
    - **传统Web应用**：适用于大多数静态网站和简单动态网站（如企业官网、博客）。
    - **API交互**：RESTful API、SOAP等基于HTTP的接口（如银行系统、政府网站）。
    - **移动应用**：部分移动端APP仍使用HTTP/1.1进行数据交互。
---
**3. HTTP/2**
- **特点**：二进制分帧、多路复用、头部压缩（HPACK）、服务器推送（Server Push）。
- **使用场景**：
    - **现代Web应用**：高交互性网站（如电商、社交媒体）。
    - **CDN优化**：减少延迟，提升资源加载速度（如视频流、图片加载）。
    - **移动端优化**：减少TCP连接数，提升移动网络下的性能。
---
**4. HTTP/3**
- **特点**：基于QUIC（UDP）、0-RTT握手、无队头阻塞、连接迁移。
- **使用场景**：
    - **高延迟/不稳定网络**：如移动网络（4G/5G）、跨国访问（减少RTT影响）。
    - **实时应用**：视频会议（如Zoom）、在线游戏、金融交易（低延迟需求）。
    - **大规模分布式系统**：如Google、Facebook等已采用HTTP/3优化全球访问体验。

QUIC为什么快，相比TCP有什么优势：
1. **减少连接建立时间**：QUIC通过在UDP（User Datagram Protocol）之上实现TLS加密和握手过程，显著减少了建立安全连接所需的时间。相比TCP加上TLS的过程，QUIC可以在一次往返时间内完成连接的建立。
2. **改进的拥塞控制**：QUIC允许更灵活的拥塞控制算法，因为它们可以直接在用户空间实现，而不是像TCP那样依赖于操作系统内核。这使得QUIC能够更快地适应网络条件的变化，并提高数据传输效率。
3. **更好的处理丢包情况**：在TCP中，一个流中的丢包会阻塞整个连接直到丢失的数据包被重传。然而，QUIC支持多路复用，这意味着每个流都是独立的，因此某个流中的丢包不会影响其他流的数据传输。
4. **无缝切换网络**：QUIC设计支持移动设备在网络之间切换时保持连接不中断。由于QUIC的连接标识不是基于IP地址和端口号，所以即使设备的IP地址发生变化，也能维持连接。
5. **增强的安全性**：QUIC默认对所有数据进行加密和认证，提供比TCP更高的安全性。相比之下，在TCP中，需要额外使用TLS来确保通信安全。

## HTTP和HTTPS

HTTPS是什么：
HTTPS（Hyper Text Transfer Protocol Secure）是HTTP协议的安全版本，用于在客户端（通常是浏览器）和服务器之间通过网络传输数据时提供加密通信。它使用SSL（Secure Sockets Layer）或其后续技术TLS（Transport Layer Security）来加密数据，确保数据的隐私性、完整性以及通信双方的身份验证。
以下是HTTPS的一些关键特性：
1. **加密**：HTTPS使用对称加密和非对称加密相结合的方式保护数据安全。这意味着即使数据在传输过程中被拦截，没有解密密钥也无法读取信息。
2. **数据完整性**：HTTPS保证了数据在传输过程中不会被篡改。如果数据在途中被修改，接收方能够检测到这种篡改。
3. **身份验证**：HTTPS通过数字证书机制确认网站的真实性。当您访问一个HTTPS网站时，您的浏览器会检查该网站的SSL/TLS证书以验证其身份。这有助于防止中间人攻击。
4. **信任与SEO优势**：使用HTTPS可以增加用户对网站的信任度，因为地址栏中会出现挂锁图标，并且浏览器会标记HTTP网站为“不安全”。此外，搜索引擎如Google已明确表示会优先索引HTTPS网站，因此采用HTTPS也对SEO（搜索引擎优化）有利。

HTTPS工作流程：
1. **客户端请求**：当用户在浏览器中输入一个HTTPS网址并按下回车键后，浏览器会向服务器发起请求，要求建立一个安全连接。 
2. **服务器响应**：服务器收到请求后，会返回其SSL/TLS证书给客户端。这个证书包含了公钥和其他标识信息，并由受信任的证书颁发机构（CA）签名以验证服务器的身份。
3. **证书验证**：客户端接收到证书后，首先需要验证证书的有效性和真实性。这包括检查证书是否过期、是否由可信任的CA签发等。如果证书有效且可信，流程继续；否则，浏览器将显示警告信息给用户。
4. **密钥交换**：一旦证书被验证通过，客户端会使用证书中的公钥加密一个随机生成的对称密钥（也称为会话密钥），然后发送给服务器。此步骤通常采用非对称加密技术（如RSA或ECDHE算法）进行密钥交换。使用对称加密是为了提高后续数据传输的效率。
5. **会话密钥确认**：服务器使用自己的私钥解密从客户端收到的信息，获取对称密钥。之后，服务器和客户端都会使用这个共享的对称密钥加密和解密双方之间的通信内容，确保数据传输的安全性。
6. **安全通信**：现在，客户端和服务器之间已经建立了安全通道，它们可以开始使用对称加密技术相互发送加密的数据。所有在此安全通道上的通信都是加密的，能够防止中间人攻击者窃听或篡改数据。
7. **关闭连接**：当数据传输完成或者一段时间没有活动后，任一方都可以关闭连接。在某些情况下，可能会重新协商新的会话密钥以维持安全性。

TLS的握手目的和过程：
**主要目的：**
- **身份验证**：通过数字证书验证通信双方的身份，防止中间人攻击。
- **协商加密参数**：客户端和服务器协商使用哪些加密算法（如对称加密算法、哈希函数等）进行数据传输。
- **生成会话密钥**：通过非对称加密技术安全地生成一个共享的秘密（即会话密钥），用于后续的数据加密和解密。

**握手过程：**
TLS握手流程可以简化为以下步骤：
1. **客户端问候(Client Hello)**：客户端发送一条消息给服务器，包含支持的TLS版本、加密套件列表（如AES、RSA等）、压缩方法以及一个随机数（Client Random）。这一步主要是告诉服务器客户端的能力和支持的选项。
2. **服务器问候(Server Hello)**：服务器从客户端提供的加密套件中选择一个，并连同选定的TLS版本、服务器的证书、另一个随机数（Server Random）以及可能的服务器密钥交换信息一起返回给客户端。此外，如果需要，还会发送请求客户端证书的信息。
3. **客户端验证并交换密钥**：
    1. 客户端首先验证服务器的证书，确认其有效性及是否由可信的CA签发。
    2. 验证通过后，客户端生成第三个随机值（Premaster Secret），用服务器的公钥加密后发送给服务器。
    3. 同时，客户端根据之前收到的两个随机数（Client Random, Server Random）和自己生成的Premaster Secret计算出会话密钥。
4. **服务器处理并完成握手**：
    1. 服务器使用自己的私钥解密来自客户端的消息，获取Premaster Secret。
    2. 然后，服务器同样基于三个随机数计算出会话密钥。
    3. 接着，服务器发送一条“Server Finished”消息给客户端，这条消息已经使用会话密钥进行了加密，表明服务器方面已经准备好开始加密通信了。
5. **客户端响应**：客户端接收到服务器的“Server Finished”消息后，也会发送一条类似的“Client Finished”消息，表示握手过程完成，双方可以开始使用会话密钥进行安全通信。

证书的颁发和验证：
**证书的颁发：**
1. **申请**：首先，网站或服务的所有者需要向证书颁发机构（CA, Certificate Authority）申请一个数字证书。申请时通常需要提供一些基本信息来证明申请者的身份和对所请求域名的所有权。
2. **验证身份**：CA会对申请者进行一系列的身份验证步骤，以确认申请者确实是其所声称的身份，并且拥有对请求域名的控制权。验证方式取决于证书的类型：
    - **域名验证（DV）**：最低级别的验证，仅确认申请人对域名的有效控制。
    - **组织验证（OV）**：除了域名验证外，还需要验证组织的存在性和合法性。
    - **扩展验证（EV）**：最高级别的验证，涉及更详细的背景检查，包括验证业务运营的合法性、物理地址等信息。
3. **颁发证书**：一旦身份验证成功，CA将生成一个包含公钥、持有者名称、有效期以及CA签名的数字证书，并将其颁发给申请者。这个证书用于在网络上识别持有者身份。

**证书的验证：**
当用户尝试访问一个使用HTTPS的网站时，浏览器会自动执行以下步骤来验证该网站的数字证书：
1. **接收证书**：浏览器从服务器接收数字证书。
2. **检查证书的有效性**：浏览器会检查证书是否在有效期内、证书是否被吊销（通过CRL或OCSP机制），以及证书是否由受信任的CA签发。
3. **构建证书链**：每个证书都可能是一个证书链的一部分，其中包含从服务器证书到根证书的一系列中间证书。浏览器会尝试构建这条证书链，并验证每个证书的真实性直到根证书，而根证书必须预先安装在浏览器的信任存储中。
4. **验证签名**：使用上一级证书中的公钥（最终追溯到根证书的公钥）来验证当前证书的数字签名。如果所有证书都能成功验证，则表明证书是可信的。
5. **建立安全连接**：一旦证书通过所有这些验证步骤，浏览器就会认为服务器是可信的，并继续进行TLS握手过程以建立加密的安全连接。

HTTP和HTTPS的区别：
1. **安全性**：
    - **HTTP**：是一种不加密的协议，数据以明文形式在网络上传输。这意味着任何中间人（如黑客）都可以轻易地窃听或篡改传输的数据。
    - **HTTPS**：通过SSL/TLS协议对HTTP请求和响应进行加密，确保了数据传输的安全性和完整性。它有效地防止了信息泄露和中间人攻击。
2. **默认端口**：
    - **HTTP**：使用80端口作为默认通信端口。
    - **HTTPS**：通常使用443端口来提供安全的通信服务。
3. **SEO优势**：
    - 谷歌等搜索引擎已经明确表示，采用HTTPS的网站会在搜索排名中获得一定的偏好。因此，从SEO的角度来看，迁移到HTTPS可以带来额外的好处。
4. **性能**：
    - 尽管HTTPS需要更多的处理能力来进行加密和解密操作，但现代硬件和优化技术（如HTTP/2的支持，它要求必须使用HTTPS）使得HTTPS在实际应用中的性能并不逊色于HTTP，甚至在某些情况下表现更好。
5. **信任度**：
    - 当访问一个HTTPS网站时，地址栏会显示一个挂锁图标，表明该连接是安全的。对于电子商务网站或其他涉及敏感信息的网站来说，这种视觉上的保证能够增加用户的信任感。相比之下，HTTP网站可能会被浏览器标记为“不安全”，这可能会影响用户对网站的信任。
6. **证书需求**：
    - HTTPS需要数字证书来建立安全连接，而HTTP则不需要。这些证书由受信任的证书颁发机构（CA）签发，并且可以是免费的（例如通过Let's Encrypt）或者付费获取更高级别的验证（如OV或EV证书）。
